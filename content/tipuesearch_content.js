var tipuesearch = {"pages": [{'title': 'week', 'text': 'week1-week5 \n week6-week9 \n week10-week14 \n week15-week18 \n', 'tags': '', 'url': 'week.html'}, {'title': 'week1-5', 'text': 'week1 \n \n 1.登入自己的github帳戶，並且創建名為cd2020的個人倉儲。 \n 2.進入存放的資料夾例如;tmp \n 3.在小黑窗上打上git clone\xa0https://github.com/s40723221/cd2020。 \n 4.git submodule add https://github.com/mdecourse/cmsimde.git。 \n 5.完成後使用cd cd2020 ->cd cmsimde進入cmsimde的資料夾內。 \n 6.完成之後使用python wsgi.py進入靜態9443內編輯個人網站的資料。 \n 7.使用git add .\xa0 -> commit -m ＂標題＂ -> git push將剛剛編輯好的東西上傳。 \n 8.進入個人倉儲的setting中更改branch(分支)至master。 \n 影片教學: \n \n \n week2 \n 將可攜系統下的python 3.7.3系統更新至python 3.8.2 \n 1.進入 https://www.python.org/downloads/windows/ \n 2.往下滑到最底，下載 Windows x86-64 executable installer (上下兩者分別為 Windows x86-64 embeddable zip file 和 Windows x86-64 web-based installer 這兩者是嵌入式64位元python的可執行壓縮檔案和64位元網際端的可執行檔案)在本次可熙的更新中不會使用到 \n \n 3.接著開始下載切記不要勾選pip選項，接著按下next \n 4.先將下載下來的python3.8.2放置桌面，並且將y槽下的data新增加一個py382的資料夾方便之後可以做測試是否3.8.2之python可以正常的運行 \n 5.將剛剛下載之python3.8.2放置於剛剛創建的py382中切記不要將原先的py373刪除，若之後py382的執行產生錯誤才可以使用py373做返回原版本的動作 \n 6.更改執行檔start_mdecourse.bat \n 將底下py373處更改為自己下在python3.8.2所儲存的資料夾名稱 \n @echo off\nset Disk=y\nsubst %Disk%: "data"\n\n%Disk%:\n\nset HomePath=%Disk%:\\home_mdecourse\nset HomeDrive=%Disk%:\\home_mdecourse\nset Home=%Disk%:\\home_mdecourse\nset USERPROFILE=%Disk%:\\home_mdecourse\n\nREM 將系統 Python 程式的 io 設為 utf-8\nset PYTHONIOENCODING="utf-8"\n\nset PYTHONPATH=%Disk%:\\py373\\DLLs;%Disk%:\\py373\\Lib;%Disk%:\\py373\\Lib\\site-packages;\nset PYTHONHOME=%Disk%:\\py373\n\nset GIT_HOME=%Disk%:\\portablegit\\bin\\\nset GIT_SSH=%Disk%:\\putty\\plink.exe\n\nset path_python=%Disk%:\\py373;%Disk%:\\py373\\Scripts;\nset path_msys2=%Disk%:\\msys64\\mingw64\\bin;\nREM coreutils is for compiling fossil scm\nset path_coreutils=%Disk%:\\coreutils-5.3.0\\bin;%Disk%:\\depends22_x64;\nset path_tcc=%Disk%:\\tcc;\nset path_cmake=%Disk%:\\cmake-3.10.1-win64-x64\\bin;\nset path_nodejs=Disk%:\\nodejs;%Disk%:\\nodejs\\appdata\\roaming\\npm;\nset path_git=%Disk%:\\portablegit\\bin;\nset path_xming=%Disk%:\\Xming;\nset path_latex=%%Disk%:\\Pandoc;%Disk%:\\TinyTeX\\bin\\win32;\n\npath=%Disk%:;%path_python%;%path_msys2%;%path_tcc%;%path_git%;%path_cmake%;%path_coreutils%;\n\nstart /MIN %Disk%:\\wscite415\\wscite\\SciTE.exe\nstart /MIN %Disk%:\\wscite415\\wscite\\SciTE.exe\n\nstart /MIN cmd.exe\nstart /MIN cmd.exe\nstart /MIN cmd.exe\nstart /MIN cmd.exe\n\n\nExit \n 7.重新啟動剛剛更新的執行檔 \n 8.執行 python get-pip.py \n 9..執行 python -m pip install flask flask-cors markdown lxml bs4 pelican leo \n 影片教學: \n \n \n git pull request操作說明: \n 1.以自己github之帳號fork老師的倉儲也就是 fork : https://github.com/mdecourse/cd2020 \n 2.接下來到自己的倉儲中找到剛剛fork下來的老師倉儲並且複製網址 \n 3.利用git clone 自己帳號下老師的網址 \n 4.在執行git submodule add  https://github.com/mdecourse/cmsimde.git \n 5.進入到9443開始編輯自己帳號下老師的網站 \n 6.編輯完成後執行git add commit push三個步驟 \n 7.利用自己帳號下修改完成的老師倉儲建立新的pull request \n \n \n 8.按下提交之後等待老師接受並且merge即可完成此次的pull request \n w2直播進程: \n 分工內容: \n 40523253:亂數分組程式 40623117:亂數分組程式 40623252:4輪車  40723221 (group leader) :4輪車  40723222:4輪車  40723228:亂數分組程式 40723236:4輪車  40723237:可攜系統 40723240:4輪車  40723243:4輪車  40723244:可攜系統 40723249:可攜系統  40732331:4輪車\xa0 \n 注意事項: \n 1.視課堂進度上傳影片 2.不管會不會做每周都要push 3.可以從gitter上面提問 4.直播大家輪流主持，直播前半部分有教大家如何開直播了 5.git pull request每個人都要會之後要更改東西比較方便 6.不會做的可以去看我的網站我會盡可能提早更新，再不行就到gitter上面提問可以在這邊提問 gitter:https://gitter.im/mdecourse/cd2020 7.2020年3月26日到期assignment 1的pdf繳交請在時間內上傳到自己倉儲的download上 8.pdf上寫上進度，之後打分數依照pdf打分 \n 直播進程影片: \n \n \n week3 \n 本周報告影片: \n \n', 'tags': '', 'url': 'week1-5.html'}, {'title': 'week6-9', 'text': '\n w2直播進程: \n 分工內容: \n topic0: 40723237 40723221 40723222 40723228 40723243 40723244 40723236 40623117 \n topic1: 40723221 40723222 40623252 40523253 40723249 40732331 40723240 40723237 \n 直播進程影片: \n \n 4輪車參考影片: \n 四輪車馬達驅動設定影片: \n \n V-REP\xa0 tutorial 影片: \n \n', 'tags': '', 'url': 'week6-9.html'}, {'title': 'week10-14', 'text': '', 'tags': '', 'url': 'week10-14.html'}, {'title': 'week15-18', 'text': '', 'tags': '', 'url': 'week15-18.html'}, {'title': 'Q&A', 'text': 'PY3.8.2更新後出現之LEO無法開啟問題與解決方法。 \n \n 拿之前home_mdecourse/.leo裡面的.leoID.txt放到home裡面就正常了。 \n', 'tags': '', 'url': 'Q&A.html'}, {'title': 'assignments', 'text': '1.assignment1: pdf報告 \n', 'tags': '', 'url': 'assignments.html'}, {'title': 'assignment1', 'text': 'assignment1pdf報告 \n Collaborative product design processes of industrial design and engineering design in consumer product companies 本書內容在講述為何要進行協同及協同對業界進行協同的實驗，以及講述協同的重要性，和對工業設計及機構設計工程師是如何在分工上取得平衡以至於不會產生衝突做講解。 \n assignment1所要解決之項目: \n 1. Describe how\xa0to\xa0do an efficient random grouping for this\xa0course or do the roll calling randomly? \n 2. Describe how to prepare a portable Python programming system for Windows 10 64bit system to allow one the maintain \xa0 CMSiMDE \xa0 website, \xa0 Pelican blog \xa0 and \xa0 Reveal.js \xa0 presentation on \xa0 Github ? \n 3. What do you need to know from\xa0 http://www.coppeliarobotics.com/helpFiles/index.html \xa0to implement a four-wheeled robot? \n', 'tags': '', 'url': 'assignment1.html'}, {'title': 'Random grouping', 'text': '資料提供及統整:40723221\xa0 \n 1.如何從網站中抓取所需之資料(如名單)? \n  2.順利抓取名單後如何運用於程式中並使其能夠正確的讀取? \n  3.如何在上述皆達成後順利達到分組的效果?    我們必須要了解 import 的 request、ast、random 是甚麼模組。 \n  (1) Request 為能夠下載網頁的一項 python 中的模組，我們能夠使用 request.get(加入網址)的方式來達到擷取網頁資料的目的。  \n 參考連結 :  https://blog.gtwang.org/programming/python-requests-module-tutorial/  (2) ast 中的 literal_eval 可以將剛剛擷取下來的網頁資料(僅允許為字符串，字  節對象(bytes)，數值，元組，列表，字典，集合，布爾值和 None)才可以進 行轉換。  \n 參考連結 :  https://docs.python.org/zh-cn/3/library/ast.html \n  (3) random 中有許多不同的用法，在每周抽點中我們使用的是 shuffle 的用法， 此 用法會將給定的元素隨機打亂，以達到亂數的目的。 \n  參考連結 :  https://ithelp.ithome.com.tw/articles/10207483  \n 最後我們可以經由 for 迴圈對剛剛打亂的元素進行我們所想要的分法已達到 亂數分組中的分組的目的。    亂數分組及每周抽點程式比較 :亂數分組必須要從 index.html 中去抓取網址， 如在 html 中不存在網址才會從主程式 evenGrouping.dart 中抓取網址，而每 周抽點的程式中則是採用 Request 的方式去產生擷取網站資料的目的，在亂 數分組中可以以 dart 的方式去 run 就會達到分組的目的，也可以使用 scite 進 行 python 指令的運行，這樣也可以對每周抽點進行抽點運行。  \n', 'tags': '', 'url': 'Random grouping.html'}, {'title': 'Portable system', 'text': '資料提供及資料統整:40723221、40723237、 40723249 、40723244\xa0 \n 問題:如何對現有的可攜進行更新 python 至 3.8.2 的動作，可攜系統的完整安裝流程，及 python3.8.2 的運行需要做哪一些更動?    (1)直接對舊有可攜進行更新  將可攜系統下的 python 3.7.3 系統更新至 python 3.8.2   \n 1.進入\xa0 https://www.python.org/downloads/windows/   2.往下滑到最底，下載 Windows x86-64 executable installer(上下兩者分別為 Windows x86-64 embeddable zip file 和 Windows x86-64 web-based installer 這兩者是嵌入式64位元python的可執行壓縮檔案和64位元網際端的可執行檔 案)在本次可攜的更新中不會使用到  3.接著開始下載切記不要勾選 pip 選項，接著按下 next  4.先將下載下來的python3.8.2放置桌面，並且將y槽下的data新增加一個py382 的資料夾方便之後可以做測試是否 3.8.2 之 python 可以正常的運行  5.將剛剛下載之 python3.8.2 放置於剛剛創建的 py382 中切記不要將原先的 py373刪除，若之後 py382 的執行產生錯誤才可以使用 py373 做返回原版本的 動作  6.更改執行檔 start_mdecourse.bat 將底下 py373 處更改為自己下在 python3.8.2 所儲存的資料夾名稱  \n [start 開啟檔的修改]  \n 7.重新啟動剛剛更新的執行檔  8.執行 python get-pip.py  9..執行 python -m pip install flask flask-cors markdown lxml bs4 pelican leo  影片教學網址\xa0: \n   (2)從頭對創建 python3.8.2 的可攜  \n 1.往下滑到最底，下載 Windows x86-64 executable installer \n  2.SciTE：到 https://www.scintilla.org/SciTEDownload.html，下載 ” full 64-bit download” 把檔案 ”wscite432” 搬移至 data 目錄底下，在到data下的wscite432 下的 wscite 目錄下執行”scite.exe”  \n 3. MSYS2：https://www.msys2.org/ 下載 msys2-x86_64-20190524.exe 並執行 \n  4. PortableGit：https://git-scm.com/download/win 下載 64-bit Git for Windows Portable 安裝在 data 目錄下  \n 5.安裝pip為以更新的方式更新可攜或者是以從頭開始的方式更新可攜都必須要 安裝指令為 python get-pip.py 6. 指令為 pip install flask bs4 lxml pelican markdown flask_cors 也必須要安裝這些模組    兩者的比較差異:更新舊有的可攜需要的主要為 python get-pip.py 與下載模 組 pip install flask bs4 lxml pelican markdown flask_cors 並且對 開啟檔 start_mdecourse.bat 進行內容的更動及可，從頭開始執行可攜的更新則 比較麻煩需要下載的模組較多，必須對 SciTE、MSYS2、PortableGit、Tiny C Compiler、Jupyterlab、Fossil SCM 有需要甚至可以將 webots、v-rep 及其他如sharex 等軟體載入可攜系統中。  \n', 'tags': '', 'url': 'Portable system.html'}, {'title': 'four wheel car', 'text': '參考書籍翻譯 \n Line following BubbleRob tutorial \n simulation \n External controller tutorial \n BubbleRob tutorial \n simulation dialog \n 試設定動力至車v-rep模型連結 \n car easy setting for motor and model.ttt \n 本資料由40723222提供 \n BubbleRob tutorial : 在此教程中可以透過我們自行設置的BubbleRob機器人進行初步的模擬，在上學期中我們有實際的以v-rep操作過這個教程，在這個教程中有含括了很多包括如何建造模型(機器人本體、輪子、後方支撐滑塊、障礙物)，並且經由設定好的距離傳感器去感知並且避開我們所設立的障礙物，其中很重要的要點是如何去設計指令使輪胎兩側的傳動器依照我們所想要的方式去做運動，且當距離感測器接近我們所設立的障礙物時，他必須要做出相對應的反應部會使其碰到障礙物，另外還必須要考慮到視覺辨識系統，使機器人在移動時我們能夠觀測到機器人前方之狀況，此教程能夠使我們更加有效率的使用v-rep這套模擬軟體。 \n 影片教學網址:   https://www.youtube.com/watch?v=CXGJmwHt81g&t=59s \n 本資料由40723243 \n Line following BubbleRob tutorial : 在此模擬教程中我們銜接上面的BubbleRob教程，我們想要使其能夠按照我們所規劃的路徑移動，在四輪車的方面這樣的功能能夠使我們有效的規劃四輪車的行走路徑，以達到更好去控制四輪的目的，在無外部控制器或者是想要直接在模擬器的環境中直接模擬可以採用該方法達到比較好的效率。 \n 本資料由40723240提供 \n External controller tutorial : 遠端控制器教程中，當我們想要從遠端電腦的方式控制我們在模擬中的物件例如:四輪車或機器人時我們就會需要一項遠程控制的控制器，我們可以參考 ROS tutorial 及 ROS 2 tutorial 來達到我們想做控制的想法， ROS 主要比較像是對於機器人的中間控制系統，他能夠藉由傳感器來指引機器人該往哪個方向移動，如下圖所示，就是 ROS 較好的解釋。 \n ROS:比較像是在負責為機器人的各個元件進行溝通與操作的一個框架，以機器人的行走為例，要讓機器人走路需要控制其底下的馬達、還有一些感測器以進行避開障礙物的功能等等，ROS內就有這種類型的函式可以讓控制馬達的程式得以與接收感測器的程式溝通。 \n \n 本資料由40723221提供 \n Simulation : 這裡主要是在描述模擬是如何建立的，在模擬中我們雖然比較不會受到的限制很少，但是因為硬體的關係我們必須要適度調整好例如:模擬的速度快慢、非主要物件的加入或移除，我們也可以從這裡看到系統是如何調整速度運行的快慢和機制。 \n 本資料由40723221提供 \n Simulation settings dialog : \n 這篇教程主要在幫助我們理解如何設定模擬時所需要設定的視窗要如何操控，並且講解當我們導入實際的時間運行時，模擬會產生怎樣的變化，但當我們使用加速或減慢時模擬的變化又會怎樣，在一般的情況下模擬的時間步長如果太快會造成模擬的結果及過程不精確甚至會有偵數漏掉的問題，如果太慢雖然會有較精確的結果和過程但會使得模擬時的總時長太久，在某些結構較符雜的模擬之下，模擬在運行到較為複雜的動作或者較難去運算的動作時會使得模擬的時間跟不上實際的時間，這時v-rep內建有寫入能夠補正此bug的方式，他可以藉由進行其他較為簡單的運動模擬時加速已達到與原先時長同步的效果。 \n 四輪車初步馬達及本體和輪胎設置影片: \n \n 總結 :完成四輪車的模擬必須要有對於模擬軟體的熟悉、馬達的設立、外部控制器的連結、模型的組立、結構的評估(過於複雜的結構可以經由省略內部某些部份零件或者是外觀零件的方式達到簡化)、內部攝像頭的設立、如何以程式(如:python)去所存於模擬中的物件並且對外部控制器做連結，若要進行只單單在模擬軟體中的模擬而不依靠外部控制器去控制作動，則必須要設定在內部模擬器中的感測器(如:距離感射器、視覺感測器等等……)並且布置如線條或者是障礙物的方式去使感測器運行，使物件達到想要的避讓或者是作動，而要達到這些都必須通過程式的設置來完成。 \n ast 模組 : https://docs.python.org/zh-cn/3/library/ast.html \n Rendom 模組 : https://ithelp.ithome.com.tw/articles/10207483 \n Request: https://blog.gtwang.org/programming/python-requests-module-tutorial/ \n mde.tw 中分組之程式 : http://mde.tw/cd2020/content/Grouping.html \n v-rep使用手冊:\xa0 http://www.coppeliarobotics.com/helpFiles/index.html \xa0 \n v-rep車輛建模設置 1 : https://blog.csdn.net/abcvincent/article/details/104030418 \n v-rep車輛建模設置2: https://blog.csdn.net/abcvincent/article/details/104031159 \n V-REP車輛建模: https://zhuanlan.zhihu.com/p/105091011 \n', 'tags': '', 'url': 'four wheel car.html'}, {'title': 'assignment2', 'text': '', 'tags': '', 'url': 'assignment2.html'}, {'title': 'refer e-book', 'text': '', 'tags': '', 'url': 'refer e-book.html'}, {'title': 'Simulation', 'text': "Simulation \n 模擬 \n A simulation in CoppeliaSim can be started, paused and stopped with [Menu bar --> Simulation --> Start/Pause/Stop simulation] or through the related toolbar buttons: \n 可以使用 [ 菜單欄 -> 模擬 -> 開始 / 暫停 / 停止模擬 ] 或通過相關的工具欄按鈕來啟動，暫停和停止 CoppeliaSim 中的模擬： \n \n [Simulation start/pause/stop toolbar buttons] \n [ 模擬開始 / 暫停 / 停止工具欄按鈕 ] \n Internally, the simulator will use additional intermediate states in order to correctly inform scripts or programs about what will happen next. Following state diagram illustrates the simulator's internal states: \n 在模擬內，模擬器將使用其他中間狀態，以正確告知腳本或程序接下來將發生的情況。以下狀態圖說明了模擬器的內部狀態： \n [Simulation state diagram] \n [ 模擬狀態圖 ] \n \n Scripts and programs should alwaysreact according to the current system call function and possibly the simulation state in order to behave correctly. It is good practice to divide each control code into at least 4 system call functions (e.g. for non-threaded child scripts): \n 腳本和程序應始終根據當前系統調用功能以及可能的模擬狀態進行反應，以便正確運行。優良作法是將每個控制代碼至少分為 4 個系統調用函數（例如，用於非線程子腳本）： \n 1.Initialization function: sysCall_init: the function is called only when the script is initialized. \n 2.Actuation function: sysCall_actuation: the function is called when actuation should happen. \n 3.Sensing function: sysCall_sensing: this function is called when sensing should happen. \n 4.Clean-up function: sysCall_cleanup: the function is called just before the script is de-initialized (e.g. at simulation end, or when the script is destroyed) \n 1.Initialization 函數： sysCall_init ：僅在腳本初始化時調用該函數。 \n 2.actuation 函數： sysCall_actuation ：應在發生 actuation 時調用該函數。 \n 3.Sensing 函數： sysCall_sensing ：當應該進行檢測時調用此函數。 \n 4.Clean-up 函數： sysCall_cleanup ：該函數在腳本未初始化之前被調用（例如在模擬結束時或腳本被銷毀時） \n \xa0 \n For examples on how to arrange a typical script, refer to the main script, the child scripts and customization scripts pages. \n 有關如何安排典型腳本的示例，請參閱主腳本，子腳本和自定義腳本頁面。 \n The simulator operates by advancing the simulation time at constant time steps. Following figure illustrates the main simulation loop \n 模擬器通過以恆定的時間步長推進模擬時間來進行操作。下圖說明了主要的模擬循環 \n Simulation loop \n \n [Main simulation loop] \n [ 主要模擬路徑參考圖 ] \n Real-time simulation is supported by trying to keep the simulation time synchronized with the real time: \n 通過嘗試使模擬時間與實時保持同步來支持實時模擬： \n \n [Real-time simulation loop] \n [ 加入真實時間後的模擬參考圖 ] \n Following represents a very simplified main client application (messaging, plugin handling and other details have been omitted for clarity purpose): \n 以下是一個非常簡單的主客戶端應用程序（為清晰起見，已省略了消息，插件處理和其他詳細信息）： \n void initializationCallback  {  \xa0\xa0\xa0 // do some initialization here \n } \n \xa0 \n void loopCallback  {  \xa0\xa0\xa0 if ( (simGetSimulationState()&sim_simulation_advancing)!=0 )  \xa0\xa0\xa0 {  \xa0\xa0\xa0\xa0\xa0\xa0\xa0 if ( (simGetRealTimeSimulation()!=1)||(simIsRealTimeSimulationStepNeeded()==1) )  \xa0\xa0\xa0\xa0\xa0\xa0\xa0 {  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if ((simHandleMainScript()&sim_script_main_script_not_called)==0)  \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 simAdvanceSimulationByOneStep();  \xa0\xa0\xa0\xa0\xa0\xa0\xa0 }  \xa0\xa0\xa0 }  } \n \xa0 \n void deinitializationCallback  {  \xa0\xa0\xa0 // do some clean-up here \n } \n Depending on the simulation complexity, performance of the computer and simulation settings, real-time simulation might not always be possible. \n 取決於模擬的複雜性，電腦的性能和模擬設置，實時模擬並不總是完美的。 \n In non real-time simulations, the simulation speed (i.e. the perceived speed) is mainly dependent on two factors: the simulation time step and the number of simulation passes for one rendering pass (see the simulation dialog for more details). In the case of a real-time simulation, the simulation speed mainly depends on the real-time multiplication coefficient, but also to a certain degree of the simulation time step (a too small simulation time step might not be compatible with the real-time character of a simulation because of the limited calculation power of the computer). During simulation, the simulation speed can be adjusted with following toolbar buttons \n 在非實時模擬中，模擬速度（即感知速度）主要取決於兩個因素：模擬時間步長和一個渲染通道的模擬通道數量（有關更多詳細信息，請參見模擬對話框）。在實時模擬的情況下，模擬速度主要取決於實時乘法係數，而且在一定程度上取決於模擬時間步長（太小的模擬時間步長可能與實時時間不兼容）。由於計算機的計算能力有限，因此無法進行模擬。在模擬過程中，可以通過以下工具欄按鈕來調節模擬速度 \n Simulation speed \n \n [Simulation speed adjustment toolbar buttons] \n The simulation speed is adjusted in a way so that the initial simulation time step is never increased (because this might have as consequence the breaking of a mechanism for example). Following two figures illustrate the simulation speed adjustment mechanisms \n 以某種方式調整模擬速度，以使初始模擬時間的步長永遠不會增加（這可能因此而導致機制中斷）。下兩個圖說明了模擬速度調節機制 \n \n [Simulation speed adjustment mechanism for non real-time simulations]  [非實時模擬的模擬速度調整機制] \n \n [Simulation speed adjustment mechanism for real-time simulations] \n [實時模擬與調整機制] \n By default, each simulation cycle is composed by following sequential operations: \n 1.Executing the main script \n 2.Rendering the scen \n 默認情況下，每個模擬週期由以下順序操作組成： \n 1. 執行主腳本 \n 2. 渲染場景 \n Threaded rendering \n The rendering operation will always increase the simulation cycle duration, thus also slowing down simulation speed. The number of main script executions per scene rendering can be defined (see further up), but this is not enough in some situations, because rendering will still slow down every xth simulation cycle (which can be handicapping with real-time requirements). For those situations, a threaded rendering mode can be activated via the user settings, or via the following toolbar button: When the threaded rendering mode is activated, a simulation cycle will only consist in execution of the main script, thus simulations will run at maximum speed. Rendering will happen via a different thread, and not slow down the simulation task. The drawbacks have however to be considered. When threaded rendering is activated, then: \n  \xa0 [Threaded rendering toolbar button] \n Rendering will happen asynchronously to the simulation loop, and visual glitches might appear \n The video recorder will not operate at constant speed (some frames might get skipped) \n The stability of the application might be reduced \n Some operations (e.g. erasing an object, etc.) require to wait for the rendering thread to finish work, before being able to execute, and vice-versa. In those situations, cycles could take more time than in the sequential rendering mode \n 交互渲染 \n 渲染操作將始終增加模擬週期的持續時間，從而也降低了模擬速度。可以定義每個場景渲染的主腳本執行次數（請參閱後面的內容），但這在某些情況下還不夠，因為渲染仍然會減慢每個第 x 個模擬週期的時間（這可能會限制實時性）。在這種情況下，可以通過用戶設置或以下工具欄按鈕激活線程渲染模式： \n \xa0[ 線程渲染工具欄按鈕 ] \n 激活線程渲染模式後，模擬週期將僅包含在執行主腳本中，因此模擬將以最大速度運行。渲染將通過不同的線程進行，並且不會減慢模擬任務的速度。然而，必須考慮缺點。激活線程渲染後，： \n 渲染將與模擬循環不會同步進行，並且可能會出現視覺上的瑕疵 \n 錄影機將無法以恆定速度運行（可能會跳過某些幀數） \n 應用程序的穩定性可能會降低 \n 某些操作（例如去除物件等）需要等待渲染得線程完成工作才能執行，反之亦然。在那些情況下，循環可能比有順序的渲染模式花費更多的時間。 \n Simulation dialog \n 模擬控制視窗 \n The simulation dialog can be accessed with [Menu bar --> Simulation --> Simulation settings] or by clicking following toolbar button: \n 可以通過 [ 菜單欄 -> 模擬 -> 模擬設置 ] 或單擊以下工具欄按鈕來訪問模擬對話框： \n \n [Simulation toolbar button] \n [ 模擬工具欄按鈕 ] \n \n [Simulation settings dialog] \n 模擬設定視窗 \n Time step: the simulation time step. Each time the main script was executed, the simulation time is incremented by the simulation time step. Using large time steps results in fast but inaccurate/unstable simulations. Small time steps on the other hand will (generally) lead to more precise simulations, but will take more time. It is highly recommended to keep a default time step. \n Simulation passes per frame (ppf): the number of simulation passes for one rendering pass. A value of 10 would mean that the main script is executed 10 times (10 simulation steps) before the screen is refreshed. If you have a slow graphic card, you can choose to display only one frame out of two for instance. \n Pause when simulation time higher than: allows specifying a simulation time at which the simulation will   be paused (e.g. to be able to analyze some results at a specific simulation time). \n Pause on script error: if enabled, then a simulation will be paused when a script error occurs. \n 時間步長：模擬時間步長。每次執行主腳本時，模擬時間都會增加模擬時間的步長。使用較大的時間步長會導致快速但不准確 / 不穩定的模擬。另一方面，較小的時間步長（通常）會有更精確的模擬，但是會花費更多時間。強烈建議保留默認的時間步長。 \n 每幀模擬次數（ ppf ）：一個渲染遍的模擬次數。其值為 10 表示刷新屏幕之前，主腳本已執行 10 次（ 10 個模擬步驟）。如果您的顯示卡較慢，則可以選擇僅顯示兩幅中的一幅。 \n 當模擬時間高於以下時間時則會暫停：允許指定暫停模擬的模擬時間（例如，能夠在特定模擬時間分析某些結果）。 \n 腳本錯誤暫停：如果啟用，則在腳本錯誤發生時暫停模擬。 \n Full screen at simulation start: if enabled, then simulation starts in full screen mode. Be aware that in full screen mode, dialogs and messages won't appear or won't be visible, and only the left mouse button will be active. For that reason that mode is only recommended once a scene is properly configured and final. Full screen mode can be left with the esc-key, and toggled via the boolean parameter sim_booparam_fullscreen during simulation. Unler Linux and MacOS the full-screen mode might only partially be supported, and switching back to normal mode might fail on certain systems. \n 模擬開始時全屏：如果啟用，則模擬以全屏模式開始。請注意，在全屏模式下，設置視窗和消息將不會出現或不可見，只有鼠標左鍵處於活動狀態時才會出現。因此，僅在正確配置場景並最終確定場景後才建議使用該模式。可以使用 esc 鍵保留全屏模式，並在模擬過程中通過布爾參數 sim_booparam_fullscreen 進行切換。  Unler Linux 和 MacOS 可能僅部分支持全屏模式，並且在某些系統上切換回普通模式可能會失敗。 \n Real-time simulation, multiplication factor: if selected, then the simulation time will try to follow the real-time. A multiplication factor of X would try to run a simulation X times faster than real-time. \n 實際時間的模擬，倍增係數：如果選擇，則模擬時間將嘗試跟隨實際時間。  X 的乘數將使模擬運行比實時快 X 倍。 \n Try catching up when behind: during real-time simulation, it can happen that the simulation time is not able to follow the real-time (e.g. because of some momentarily heavy calculations). In that case, if this check-box is selected, then the simulation time will try catching up the lost time (e.g. when the calculation load is again reduced), which results in an apparent speed-up. \n 在落後時嘗試趕上：在實時模擬過程中，模擬時間可能無法實時跟踪（例如，由於某些瞬間繁重的計算）。在這種情況下，如果選中此複選框，則模擬時間將嘗試趕上不足的時間（例如，當計算負載再次減少時），從而明顯加快速度。 \n Reset scene to initial state: when selected, then all objects will be reset to their initial state: this includes the object local position, local orientation and its parent (as long as the object wasn't modified otherwise (e.g. scaled)), joint and path intrinsic positions, floating view positions and sizes, etc. This means that the next simulation run will execute in a same way as previous one, unless heavy changes were undertaken (shape scaling, object removal, etc.). Some minor settings are ignored by this item. \n 將場景重置為初始狀態：選中後，所有物件都將重置為其初始狀態：包括對象的局部位置，局部方向及其父對象（只要未進行其他修改（例如，縮放），以及路徑的固有位置，浮動視圖的位置和大小等。這意味著除非進行了重大更改（形狀縮放，對象移除等），否則下一次模擬運行將以與上一次相同的方式執行。此項目將忽略一些次要設置。 \n Remove new objects: when selected, then scene objects added during a simulation run will be removed at the end of the simulation. \n 刪除新對象：選中後，在模擬運行期間添加的場景對象將在模擬結束時被刪除。 \n", 'tags': '', 'url': 'Simulation.html'}, {'title': 'line following bubblerob', 'text': "使  BubbleRob  沿著線性的教程 \n In this tutorial we aim at extending the functionality of BubbleRob to let him/her follow a line on the ground. Make sure you have fully read and understood the  first BubbleRob tutorial . This tutorial is courtesy of Eric Rohmer. \n 在本教程中，我們要擴展  BubbleRob  的功能，以使他遵循地面上的軌跡。確保您已經 閱讀並理解了第一個  BubbleRob  教程。本教程由  Eric Rohmer  提供。 \n Load the scene of the first BubbleRob tutorial located in CoppeliaSim's installation folder, in tutorials/BubbleRob. The scene file related to this tutorial is located in tutorials/LineFollowingBubbleRob. Following figure illustrates the simulation scene that we will design: \n 在  CoppeliaSim  的安裝文件夾中的  tutorials / BubbleRob  中加載第一個  BubbleRob  教程 的場景。與本教程相關的場景文件位於  tutorials / LineFollowing BubbleRob  中。下圖說 明了我們將設計的仿真場景： \n \n We first create the first of 3  vision sensors  that we will attach to the  bubbleRob  object. Select [Menu bar --> Add --> Vision sensor --> Orthographic type]. Edit its properties, by double-clicking on the newly created vision sensor icon in the  scene hierarchy , and change the parameters to reflect following dialog: \n 我們首先創建三個視覺傳感器中的第一個，並將其附加到  bubbleRob  物件中。選擇 [ Menu bar  ->  Add  ->  Vision sensor  ->  Orthographic type ] 。通過雙擊場景中新創建的覺傳感器圖標來編輯其屬性，並更改參數以反映以下對話框： \n \n The vision sensor has to be facing the ground, so select it, and in the orientation dialog, on the orientation tab, set [180;0;0] for the Alpha-Beta-Gamma items. \n 視覺傳感器必須面向地面，因此選擇它，然後在“ orientation ”對話框中的 “ orientation ”選項上，將“  Alpha-Beta-Gamma ”項設置為 [180; 0; 0] 。 \n We have several possibilities to read a vision sensor. Since our vision sensor has just one pixel and operates in an easy way, we will simply query the average intensity value of the image read by our vision sensor. For more complex cases, we could have set-up a vision callback function. Now copy and paste the vision sensor twice, and adjust its names to leftSensor, middleSensor and rightSensor. Make bubbleRob their parent (i.e. attach them to the bubbleRob object). Your sensors should now look like this in the scene hierarchy: \n 我們有幾種可能可以讀取視覺傳感器的方式。由於我們的視覺傳感器只有一個像素， 並且操作簡單，因此我們只需查詢視覺傳感器讀取的圖像的平均強度值即可。對於更 複雜的情況，我們可以設置視覺回調函數。現在，複製並貼上視覺傳感器兩次，並將 其名稱調整為  leftSensor ，  middleSensor  和  rightSensor 。將  bubbleRob  設置為其父級 （即，將其附加到  bubbleRob  對象）。現在，您的傳感器在場景層次中應如下所示： \n Let's position the sensors correctly. For that use the position dialog, on the position tab, and set following absolute coordinates: \n 讓我們正確放置傳感器。為此，使用位置對話框，在位置選項上，並設置以下絕對坐 標： 左傳感器：  [0.2; 0.042; 0.018] 中間傳感器：  [0.2; 0; 0.018] 右傳感器：  [0.2; -0.042; 0.018] \n Now let's modify the environment. We can remove a few cylinders in front of BubbleRob. Next, we will build the path that the robot will try to follow. It is probaby better to switch to a top view from now on: select page 4 via the page selector toolbar button. Then click [Menu bar --> Add --> Path --> Circle type]. Enable the object movement with the mouse. You have two possibilities to adjust the shape of the path: \n 現在我們可以修改環境。我們可以移去  BubbleRob  前面的幾個圓柱體。接下來，我們將構建機器人將嘗試使機器人遵循的路徑。從現在開始最好切換到頂視圖：通過頁面選擇器工具欄按鈕選擇頁面  4 。然後單擊 [ 菜單欄 -> 添加 -> 路徑 -> 圓圈類型 ] 。使用鼠標啟用對象移動。您可以通過兩種方式調整路徑的形狀： \n 1.  選擇路徑（並且只有路徑）後，按住  Ctrl  並單擊其控制點之一。然後可以將它們 拖動到正確的位置。 2.  選擇路徑後，進入路徑編輯模式。在那裡，您可以自由地調整各個路徑控制點。 \n Once you are satisfied with the geometry of the path (you can always modify it at a later stage), select it, and uncheck Show orientation of points, Show path line and Show current position on path in the path properties. Then click Show path shaping dialog. This opens the path shaping dialog. Click Path shaping enabled, set the type to horizontal segment, and Scaling factor to 4.0. Finally adjust the color to black. There is a last important adjustment we have to make to the path: currently, the z-position of the path coincides with the zposition of the floor. The consequence is that sometimes we see the path, sometimes the floor (this effect is known as z-fighting in the openGl jargon). This not only affects what we see, but also what the vision sensors see. In order to avoid problems linked to z-fighting, just move the position of the path object up by 0.5 mm. \n 一旦對路徑的幾何形狀滿意（您隨時可以在以後的階段對其進行修改），請選擇它，然後在路徑屬性中取消“ Show orientation of points  顯示點的方向”，“ Show path line 顯示路徑線”和“ Show current position on path in the path properties  顯示路徑上的當前位置”。然後單擊顯示路徑外型的對話框。這將打開路徑外型對話框。單擊啟用路徑外型，將類型設置為水平線段，並將縮放因子設置為  4.0 。最後將顏色調整為黑 色。我們必須對路徑進行最後一個重要的調整：當前， 路徑的  z  位置與地板的  z  位置重合。結果是有時我們會看到路徑，有時會看到地板（這種效果在  openGl  中被稱為 “ z-fighting ”）。這不僅影響我們所看到的，而且還會影響視覺傳感器所看到的。為了避免與  z-fighting  有關的問題，只需將路徑對象的位置向上移動  0.5  毫米 \n The last step is to adjust the controller of BubbleRob, so that it will also follow the black path. Open the child script attached to bubbleRob, and replace it with following code: \n 最後一步是調整  BubbleRob  的控制器，使其也將遵循黑色路徑。打開附加到 bubbleRob  的子腳本，並將其替換為以下代碼： \n \n You can easily debug your line following vision sensors: select one, then in the scene view select [Right-click --> Add --> Floating view], then in the newly added floating view select [Right click --> View --> Associate view with selected vision sensor]. \n 您可以輕鬆地調試以下視覺傳感器的線：選擇一個，然後在場景視圖中選擇 [ 右鍵 -> 添加 -> 浮動視圖 ] ，然後在新添加的浮動視圖中選擇 [ 右鍵 -> 視圖 - -> 將視圖與選定的視覺傳感器關聯 ] 。 \n Finally, remove the auxiliary items that were added in the  first BubbleRob tutorial : remove the image processing vision sensor, its associated floating view, the floating view representing the obstacle clearance. Remove also the distance calculation object via the  distance dialog . That's it! \n 最後，刪除在第一個  BubbleRob  教程中添加的輔助項：刪除圖像處理視覺傳感器，其關聯的浮動視圖，該浮動視圖表示障礙物的清除。通過距離對話框也刪除距離計算對象。 \n", 'tags': '', 'url': 'line following bubblerob.html'}, {'title': 'External controller tutorial', 'text': "外部控制器教程 \n There are several ways one can control a robot or simulation in CoppeliaSim: \n 在  CoppeliaSim  中，有幾種方法可以控制機器人或使其模擬更加仿 真： \n The most convenient way is to write a  child script  that will handle the behaviour of a given robot or  model . It is the most convenient way, because child scripts are directly attached to  scene objects , they will be duplicated together with their associated scene objects, they do not need any compilation with an external tool, they can run in  threaded  or  non-threaded  mode, they can be extended via  custom Lua function  or via a  Lua extension library . Another major advantage in using child scripts: there is no communication lag as with the last 3 methods mentioned in this section (i.e. the  regular API  is used), and child scripts are part of the application main thread (inherent synchronous operation). There are several drawback to writing scripts however: you don't have the choice of the programming language, you can't have the fastest code, and you can't directly access external function libraries, except the Lua extension libraries. \n 最方便的方法是編寫一段指令來處理給定機器人或模型的動作。這 是最方便的方法，因為指令直接附加到物件上，它們將與相關的物 件一起復制，它們不需要使用外部工具進行任何編譯，它們可以在 線性或非線性模式下運行，它們可以通過自定義  Lua  函數或  Lua  擴 展庫進行擴展。使用指令的另一個主要優點是：與本節中提到的後 3  種方法（即使用常規  API ）一樣，沒有通信延遲，並且指令是應用 程序主線程的一部分（固有的同步操作）。但是，編寫指令有幾個缺 點：您無法選擇編程語言，不能擁有最快的代碼，並且除了  Lua  擴 展庫之外，您無法直接訪問外部函數庫。 \n Another way one can control a robot or a simulation is by writing a  plugin . The plugin mechanism allows for callback mechanisms,  custom Lua function registration , and of course access to external function libraries. A plugin is often used in conjunction with child scripts (e.g. the plugin registers custom Lua functions, that, when called from a child script, will call back a specific plugin function). A major advantage in using plugins is also that there is no communication lag as with the last 3 methods mentioned in this section (i.e. the  regular API  is used), and that a plugin is part of the application main thread (inherent synchronous operation). The drawbacks with plugins are: they are more complicated to program, and they need to be compiled with an external too. Refer also to the  plugin tutorial . \n 可以控制機器人或模擬的另一種方法是編寫插件。插件機制允許使 用回調機制，自定義  Lua  函數註冊，當然還可以訪問外部函數庫。 插件通常與指令結合使用（例如，插件註冊自定義的  Lua  函數，當 從指令中調用時，該  Lua  函數將回調特定的插件函數）。使用插件的 主要優勢還在於，與本節中提到的後  3  種方法（即使用常規  API ）一 樣，沒有通信延遲，並且插件是應用程序主線程的一部分（固有的 同步操作）。插件的缺點是：它們的編程更加複雜，並且也需要使用 外部編譯。另請參閱插件教程。 \n A third and forth way one can control a robot or a simulation is by writing an external client application that relies on the remote API. This is a very convenient and easy way, if you need to run the control code from an external application, from a robot or from another computer. This also allows you to control a simulation or a model (e.g. a virtual robot) with the exact same code as the one that runs the real robot. The remote API comes in two versions: the B0-based remote API, and the legacy remote API. \n 控制機器人或模擬的第三種方法是編寫依賴於遠程  API  的外部客戶 端應用程序。如果您需要從外部應用程序，機器人或另一台電腦運 行控制代碼，這是一種非常便捷的方法。這也使您可以使用與運行 真實機器人完全相同的代碼來控制仿真機器人或模型（例如虛擬機 器人）。遠程  API  有兩個版本：基於  B0  的遠程  API  和舊版遠程  API 。 \n A fifth way to control a robot or a simulation is via a  ROS  node. In a similar way as the  remote API , ROS is a convenient way to have several distributed processes communicate with each other. While the remote API is very lightweight and fast, it allows only communication with CoppeliaSim. ROS on the other hand allows connecting virtually any number of processes with each other, and a large amount of compatible libraries are available. It is however heavier and more complicated than the remote API. Refer to the  ROS interfaces  for details. \n 控制機器人或仿真的第五種方法是通過  ROS  節點。  ROS  與遠程  API 相似，是使多個分佈式進程相互通信的便捷方法。儘管遠程  API  非 常輕巧且快速，但它僅允許與  CoppeliaSim  通信。另一方面，  ROS  允 許幾乎將任意數量的進程相互連接，並且提供了大量兼容的庫。但 是，它比遠程  API  多並且更複雜。有關詳細信息，請參閱  ROS  接 口。 \n A sixth way to control a robot or a simulation is via a  BlueZero  (BØ ) node. In a similar way as ROS, BlueZero is a convenient way to have several distributed processes communicate with each other, and is a lightweight and cross-platform solution. Refer to the  BlueZero interface  for details. \n 控制機器人或模擬的第六種方法是通過  BlueZero （  BØ  ）節點。與 ROS  類似，  BlueZero  是使多個分佈式進程相互通信的一種便捷方 法，並且是一種輕量的跨平台解決方案。有關詳細信息，請參考 BlueZero  界面。 \n A seventh way to control a robot or a simulation is by writing an external application that communicates via various means (e.g. pipes, sockets, serial port, etc.) with a CoppeliaSim plugin or CoppeliaSim script. Two major advantages are the choice of programming language, which can be just any language, and the flexibility. Here also, the control code can run on a robot, or a different computer. This way of controlling a simulation or a model is however more tedious that the methods with the  remote API . \n 控制機器人或模擬的第七種方法是編寫一個外部應用程序，該應用 程序通過各種方式（例如管道，套接字，串行端口等）與 CoppeliaSim  插件或  CoppeliaSim  腳本進行通信。選擇編程語言（可 以是任何一種語言）和靈活性是兩個主要優點。同樣，控制代碼也 可以在機器人或其他電腦上運行。但是，與使用遠程  API  的方法相 比，這種控制仿真或模型的方法更加乏味。 \n There are 8 scene files related to this tutorial: scenes/controlTypeExamples/controlledViaScript : one robot is controlled via a  non-threaded child script , the other is controlled via a  threaded child script . scenes/controlTypeExamples/controlledViaPlugin : the robot is controlled via a  plugin . scenes/controlTypeExamples/controlledViaB0RemoteApi : the robot is controlled via the  B0-based remote API . scenes/controlTypeExamples/controlledViaLegacyRemoteApi : the robot is controlled via the  legacy remote API . scenes/controlTypeExamples/controlledViaB0 : the robot is controlled via the  BlueZero interface . scenes/controlTypeExamples/controlledViaRos : the robot is controlled via the  ROS interface . scenes/controlTypeExamples/controlledViaRos2 : the robot is controlled via the  ROS2 interface . scenes/controlTypeExamples/controlledViaTcp : the robot is controlled via  LuaSocket  and TCP. \n 有  8  個與本教程相關的場景文件：  scenes / controlTypeExamples / 受 控  ViaScript ：一個機器人是通過非線程子腳本控制的，另一個是通過 線程子腳本控制的。  scenes / controlTypeExamples / 受控 ViaPlugin ：機器人是通過插件控制的。  scenes / controlTypeExamples / controlViaB0RemoteApi ：通過基於  B0  的遠程 API  來控制機器人。  scenes / controlTypeExamples / 受控 ViaLegacyRemoteApi ：通過舊版遠程  API  控制機器人。  scenes / controlTypeExamples / controlViaB0 ：通過  BlueZero  界面控制機器 人。  scenes / controlTypeExamples / 受控  ViaRos ：通過  ROS  接口控 制機器人。  scenes / controlTypeExamples / controlViaRos2 ：通過 ROS2  接口控制機器人。  scenes / controlTypeExamples / 受控 ViaTcp ：通過  LuaSocket  和  TCP  控制機器人。 \n \n In all 8 cases,  child scripts  are used, mainly to make the link with the outside world (e.g. launch the correct client application, and pass the correct object handles to it). There are two other ways one can control a robot, a simulation, or the simulator itself: by using  customization scripts , or  add-ons . They are however not recommended for control and should be rather used to handle functionality while simulation is not running. As an example, the child script linked to the robot in scene  controlledViaB0RemoteApi.ttt  has following main task: \n 在所有 8 種情況下， 都使用子腳本，主要是為了與外界建立鏈接 （例如，啟動正確的客戶端應用程序，並將正確的對象句柄傳遞給 它）。有兩種其他方法可以控制機器人，模擬或模擬器本身：使用自 定義腳本或附加組件。但是，不建議將它們用於控制，而應在不運 行模擬時將其用於處理功能。例如，鏈接到場景控制的 ViaB0RemoteApi.ttt 中的機器人的子腳本具有以下主要任務： \n Launch the controller application ( bubbleRobClient_b0RemoteApi ) with some object handles as arguments. The server functionality of the B0-based remote API is provided by object  b0RemoteApiServer . As another example, the child script linked to the robot in scene  controlledViaRos.ttt  has following main tasks: Check if the  ROS Interface  for CoppeliaSim was loaded Launch the controller application ( rosBubbleRob ) with some topic names or object handles as arguments \n 使用某些對象作為參數啟動控制器應用程序 （  bubbleRobClient_b0RemoteApi ）。基於對象  B0  的遠程  API  的服 務器功能由對象  b0RemoteApiServer  提供。作為另一個示例，鏈接 到場景控制的  ViaRos.ttt  中的機器人的子腳本具有以下主要任務： 檢查是否已加載  CoppeliaSim  的  ROS  接口使用某些主題名稱或對象 作為參數啟動控制器應用程序（  rosBubbleRob ） \n Yet, as another example, the child script linked to the robot in scene  controlledViaTcp.ttt  has following main tasks: Search for a free socket connection port Launch the controller application ( bubbleRobServer ) with the chosen connection port as argument Locally connect to the controller application At each simulation pass, send the sensor values to the controller, and read the desired motor values from the controller At each simulation pass, apply the desired motor values to the robot's joints\xa0 Run the simulations, and copy-and-paste the robot: you will see that the duplicated robots will directly be operational, since their attached child scripts are in charge of launching new instances of their respective external applications, or calling the appropriate plugin functions. \n 然而，作為另一個示例，鏈接到場景控制的  ViaTcp.ttt  中的機器人的 子腳本具有以下主要任務：搜索空閒的套接字連接端口使用所選的 連接端口作為參數啟動控制器應用程序（  bubbleRobServer ）本地連 接到控制器應用程序在每次仿真過程中，將傳感器值發送到控制 器，並從控制器讀取所需的電機值在每次模擬過程中，將所需的電 機值應用於機器人的關節運行模擬，然後復制並粘貼機器人：您將 看到重複的機器人將直接運行，因為它們附加的子腳本負責啟動各 自外部應用程序的新實例或調用適當的插件功能。    ", 'tags': '', 'url': 'External controller tutorial.html'}]};